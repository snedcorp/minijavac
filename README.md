<h1>minijavac</h1>

<a href="https://github.com/snedcorp/minijavac/actions/workflows/build.yaml"><img src="https://github.com/snedcorp/minijavac/actions/workflows/build.yaml/badge.svg?branch=main" alt="build"></a>

`minijavac` is a minimal Java compiler that supports a limited, yet meaningful, subset of the Java language.

Built from the ground up as a learning exercise, it implements syntactic analysis, semantic analysis, and bytecode
generation entirely from scratch, without the use of any third-party libraries.[^1]

For the features it supports, `minijavac` makes every attempt to closely replicate the behavior of `javac` - source files that
produce errors in `javac` should yield similar errors in `minijavac`, with their resulting messages presented to the user in a nearly identical format.[^2]

The bytecode generated by `minijavac` is fully compliant with the [The Java Virtual Machine Specification - Java SE 17 Edition](https://docs.oracle.com/javase/specs/jvms/se17/html/index.html)[^3], 
ensuring it can be executed with the corresponding `java` utility to similar effect as bytecode produced by `javac`, despite potential differences at the byte level between the class files.

[^1]: Save `jackson-dataformat-yaml` for YAML processing, `picocli` for CLI functionality, and UNC's COMP 520 for the initial version of the `ast` package.

[^2]: Caret placement, in particular, is prone to divergence.

[^3]: The choice of JVM spec was largely arbitrary, as no Java 8+ features are supported yet.

## Table of Contents

- [minijavac](#minijavac)
  - [Table of Contents](#table-of-contents)
  - [Usage](#usage)
  - [Features](#features)
  - [Limitations](#limitations)
  - [Examples](#examples)
  - [Implementation](#implementation)
  - [Appendix](#appendix)

## Usage

For the (few) options it supports, the `minijavac` CLI interface mimics the conventions and behavior of its `javac` equivalent.

```
Usage: minijavac [-d=<destinationDir>] [-sourcepath=<sourcePath>] <files>...
minimal Java compiler
      <files>...         Specify source files to compile.
  -d=<destinationDir>    Specify where to place generated class files
      -sourcepath, --source-path=<sourcePath>
                         Specify where to find input source files
```

See [here](#i-usage) for usage examples.

## Features

### Program Structure
- **Classes**: Allows for the definition of multiple Java classes, within the same file or from different files, each with their own fields, methods, and constructors.
- **Fields**: Supports both instance and static fields with these data types: `int`, `float`, `boolean`, arrays, or user-defined types. Possible modifiers include `public`, `private`, `static`, and `final`.

### Methods and Constructors
- **Methods**: Supports both instance and static methods with these return types: `int`, `float`, `boolean`, arrays, user-defined types, or `void`. Possible modifiers include `public`, `private`, and `static`.
  - Overloading is supported, allowing multiple methods within a class to possess the same name, but different parameter lists.

- **Constructors**: Parameterized constructors are supported, to enable customized object instantiation.
  - Overloading is also supported for constructors, allowing multiple constructors with varying parameters.
  - Constructor chaining is available using `this()` to invoke another constructor within the same class.

### Modifiers
- **Visibility Modifiers**: `public`, `private`, package-private (for fields, methods, and constructors).
  - Private members can only be accessed within the same class.
- **Access Modifiers**: `static` (for fields and methods).
  - Static members:
    - Are shared across all instances of a class.
    - Cannot directly access non-static members of the same class.
- **Other Modifiers**: `final` (for fields, methods, and parameters).
  - Final members and parameters cannot be reassigned to.

### Statements
- **Control Flow**:
   - `if`, `else if`, and `else` statements for conditional branching.
   - `while`, `do while`, and `for` loops for iteration.
   - `break` and `continue` statements for controlling loop execution.
   - `return` statements, with or without an expression, for method returns.
- **Block Statements**: Supports nested blocks using `{}`.
- **Variable Declarations**: Local variables can be declared, with optional initialization.
- **Assignments**: Includes support for various assignment operators (`=`, `+=`, `-=`, `*=`, `/=`, etc.).

### Scoping
- **Variables** follow Java's scoping rules, ensuring:
  - Variables declared in inner blocks or methods are not accessible outside their defined scope.
- **Shadowing** is handled correctly, allowing:
  - Variables declared within inner blocks to shadow variables declared within outer blocks.
  - Variables and parameters declared within a method to shadow fields at the class level.

### Expressions
- **Arithmetic Operators**: 
  - Addition (`+`)
  - Subtraction (`-`)
  - Multiplication (`*`)
  - Division (`/`)
  - Modulus (`%`)
- **Logical Operators**: 
  - AND (`&&`)
  - OR (`||`)
  - NOT (`!`)
- **Bitwise Operators**: 
  - Inclusive OR (`|`)
  - Exclusive OR (`^`)
  - AND (`&`)
  - Shifts (`<<`, `>>`, `>>>`)
- **Relational Operators**: 
  - Equality (`==`, `!=`)
  - Greater/less than (`<`, `>`, `<=`, `>=`)
- **Unary Operators**: 
  - Prefix and postfix increment (`++`)
  - Prefix and postfix decrement (`--`)
  - Logical negation (`!`)
  - Bitwise complement (`~`)
  - Negation (`-`)
- **Ternary Operator**: Conditional expressions using `? :`.
- **Operator Precedence**: All operators follow Java's standard operator precedence and associativity rules, ensuring expressions are evaluated in the correct order.
  - Parentheses can be used to explicitly define precedence in complex expressions.

### References
- **Identifiers**: Variables, fields, methods, and classes can be referenced by their names (e.g., `x`, `myMethod`, `MyClass`).
- **Qualified References**: Enables accessing fields or methods of an object or class using the dot operator (`.`), such as `object.fieldName` or `ClassName.staticMethod()`.
- **Indexed References**: Enables indexing into arrays using square brackets (`[]`).
  - Supports multidimensional arrays of arbitrary depth (e.g., `array[0][1][2]`).
- **This References**: `this` refers to the current class instance.
- **Call References**: Enables the invocation of methods or constructors using parentheses (`()`), which may include arguments (e.g., `methodName(arg1, arg2)`).
- **Chained References**: Different types of references can be chained together in different ways for nested access of arbitrary depth. 
  - Some (contrived) examples of supported chained references:
    - `a.b.c.d`
    - `this.x(1).val`
    - `arr[0][1].val.convert()[2]`
    - `x().y().z()`
    - `this(1, 2).x[0]`

### Data Types
- **Primitive Types**: `int`, `float`, `boolean`.
- **Custom Types**: User-defined class types.
- **Arrays**: Single and multidimensional arrays of arbitrary depth, for all supported types.
  - Supports special `.length` property.

### Object Creation
- **Objects**: Supports object instantiation using the `new` keyword, followed by the class name and an optional argument list (e.g. `new Test()`, `new Test(1, 2)`)
- **Arrays**: Supports array instantiation using the `new` keyword, followed by the base type and the dimension sizes (e.g. `new int[2][4]`).
  - Can optionally perform initialization with `{}` (e.g. `new int[][]{{5, 6}, {7, 8}}`)

### Literals
- **Integer Literals**: Whole numbers in decimal format (e.g., `42`, `0`, `-7`).
- **Float Literals**: Decimal numbers with a fractional part (e.g., `3.14`, `0.0`, `-2.718`).
- **Boolean Literals**: Represents truth values with `true` and `false`.
- **Null Literal**: The special literal `null`, representing a null reference.

### Standard Library
- `System.out.println()` is supported for `int`, `float`, and `boolean` operands.

### Comments
- Single-line (`//`) and multi-line (`/* */`) comments are supported.

## Limitations

No support (yet) for:
 - Immediate dereferencing of new object expressions
 - Field declarations with initialization
 - Type conversions
 - Narrow integer types (`byte`, `short`) - get sign-extended to `int` anyway
 - Widened number types (`long`, `double`)
 - `char`
 - `String`[^4]
 - Switch statements
 - Static initialization blocks
 - Enhanced for loops
 - Loop labels
 - Try / catch blocks
 - Exceptions
 - Interfaces
 - Enums
 - Inheritance
 - Generics
 - Standard library methods beyond `System.out.println`
 - Nested classes
 - Packages
 - Annotations
 - Java 8+ features:
   - Lambda expressions
   - Streams
   - Switch expressions
   - Records
   - etc.

[^4]: Technically, references to the String type are allowed, to enable the main method - but that's it.

## Examples

The following are examples of Java programs that can be successfully compiled by `minijavac` for execution by the JVM:
- [Fibonnaci](src/test/resources/integration/programs/Fibonacci.java)
- [Factorial](src/test/resources/integration/programs/Factorial.java)
- [Hamming Weight](src/test/resources/integration/programs/HammingWeight.java)
- [Pascal's Triangle](src/test/resources/integration/programs/PascalsTriangle.java)
- [Merge Sorted Arrays](src/test/resources/integration/programs/MergeSortedArrays.java)
- [Binary Search](src/test/resources/integration/programs/BinarySearch.java)
- [Square Root](src/test/resources/integration/programs/Sqrt.java)
- [Reverse Integer](src/test/resources/integration/programs/ReverseInteger.java)
- [Implement Queue](src/test/resources/integration/programs/Queue.java)
- [Implement Min-Heap](src/test/resources/integration/programs/MinHeap.java)
- [Kth Largest Element](src/test/resources/integration/programs/KthLargestElement.java)
- [Valid Sudoku](src/test/resources/integration/programs/ValidSudoku.java)
- Sorting:
  - [Bubble Sort](src/test/resources/integration/programs/sort/BubbleSort.java)
  - [Selection Sort](src/test/resources/integration/programs/sort/SelectionSort.java)
  - [Insertion Sort](src/test/resources/integration/programs/sort/InsertionSort.java)
  - [Merge Sort](src/test/resources/integration/programs/sort/MergeSort.java)
  - [Quick Sort](src/test/resources/integration/programs/sort/QuickSort.java)
  - [Counting Sort](src/test/resources/integration/programs/sort/CountingSort.java)
  - [Radix Sort](src/test/resources/integration/programs/sort/RadixSort.java)
  - [Bucket Sort](src/test/resources/integration/programs/sort/BucketSort.java)
- Linked List:
  - [Implement Linked List](src/test/resources/integration/programs/linkedlist/LinkedList.java)
  - [Remove From Linked List](src/test/resources/integration/programs/linkedlist/Remove.java)
  - [Reverse Linked List](src/test/resources/integration/programs/linkedlist/Reverse.java)
  - [Odd Even Linked List](src/test/resources/integration/programs/linkedlist/OddEven.java)
- Tree:
  - [Preorder Traversal](src/test/resources/integration/programs/tree/PreOrder.java)
  - [Inorder Traversal](src/test/resources/integration/programs/tree/InOrder.java)
  - [Postorder Traversal](src/test/resources/integration/programs/tree/PostOrder.java)
  - [Breadth-First Search](src/test/resources/integration/programs/tree/BFS.java)
  - [Same Tree](src/test/resources/integration/programs/tree/SameTree.java)
  - [Max Depth](src/test/resources/integration/programs/tree/MaxDepth.java)
  - [Path Sum](src/test/resources/integration/programs/tree/PathSum.java)
  - [Lowest Common Ancestor](src/test/resources/integration/programs/tree/LowestCommonAncestor.java)
  - [Validate Binary Search Tree](src/test/resources/integration/programs/tree/ValidateBST.java)

## Implementation

### Compilation Phases

For each valid source `.java` file to be compiled by `minijavac`, the following steps occur, in order:
- **Parse**
  - [Parser](src/main/java/minijavac/syntax/Parser.java) utilizes [Scanner](src/main/java/minijavac/syntax/Scanner.java) to group the source file into tokens, which are then used by the Parser to construct an [AST](src/main/java/minijavac/ast/AST.java) (Abstract Syntax Tree) for the class.[^5]
- **Enter**
  - [Enter](src/main/java/minijavac/context/enter/Enter.java) traverses the AST and flags the presence of all references to unresolved (not-yet-parsed) classes within it, ensuring the compiler will attempt to parse all classes necessary for compilation - even those not explicitly specified by the user.
- **Context**
  - [Context](src/main/java/minijavac/context/Context.java) traverses the AST and performs semantic analysis on its contents, verifying its readiness for compilation.
- **Gen**
  - [Generator](src/main/java/minijavac/gen/Generator.java) traverses the AST and transforms it into a [ClassFile](src/main/java/minijavac/gen/file/ClassFile.java), whose byte stream representation can then be written to disk as the resulting `.class` file.

[^5]: Note that a `.java` source file can contain multiple classes - in that case, multiple ASTs will be constructed from the file. Once that occurs, there is no logically coupling between those classes, they are then processed independently.

### Parse and Enter

To coordinate these initial phases, the [Compiler](src/main/java/minijavac/Compiler.java) maintains a queue of yet-to-be-parsed source files, initially populated by the files specified by the user. 

Once a file is dequeued, it is parsed, and if valid, its ASTs are then "entered" and marked ready for semantic analysis. 

By entering a file's ASTs, we ensure that if they reference any classes that the Compiler hasn't parsed (or enqueued) yet, the corresponding files for those classes are enqueued as well.

This process will repeat until the queue has been emptied, at which point semantic analysis can proceed.

### Error Reporting

Classes that can detect errors are injected with a [Listener](src/main/java/minijavac/listener/Listener.java) upon instantiation, and use that
Listener to record errors as they occur.

Each error is represented as an instance of [CompileError](src/main/java/minijavac/err/CompileError.java) or one of its subclasses. At a minimum, an error object includes:
- A [Position](src/main/java/minijavac/syntax/Position.java) that specifies where the error occurred, including:
  - File name
  - Line number
  - Offset within the line
- A message providing details about the error.

Note that the presence of errors detected for a class does not prevent other classes from advancing through the Parse, Enter, and Context phases.
However, before the code generation step, errors become blocking — if any class contains errors, compilation cannot proceed for any of them.

#### Formatting

By default, errors are handled by [PrintListener](src/main/java/minijavac/listener/PrintListener.java), which maintains a familiar experience
for users by printing those errors to stderr in exactly the same format as `javac`.

Consider the following example:

```
Test.java:3: error: incompatible types: boolean cannot be converted to int
        int d = false;
                ^
1 error
```

Each line has a specific, familiar meaning:
1. File name, line number, and error message.
2. Actual line of code where the error occurred.
3. A caret (`^`) symbol, pointing directly to the part of the line that triggered the error.
4. The total number of errors found in the compilation process.

See [here](#ii-errors) for error examples.

### Parse

[Parser](src/main/java/minijavac/syntax/Parser.java) is a top-down, recursive descent parser responsible for transforming a stream of 
tokens from a file into one or more [ClassDecl](src/main/java/minijavac/ast/ClassDecl.java) AST nodes, each representing a
Java class defined in the source file.

This transformation follows the grammar outlined [here](#iii-grammar), guiding the Parser as it recursively
constructs the program's structure from the tokenized input.

When an unexpected or invalid token is encountered, an error is logged, and an attempt is then made to skip 
ahead to the next recognizable statement. While this approach cannot recover from severely malformed input, it does allow the 
Parser to detect and report multiple syntax errors in files that are mostly correct, thus improving the user experience[^6].

[^6]: The only error scenario considered immediately unrecoverable by the Parser is encountering an unexpected end-of-file (EOF) token before the 
AST has been fully constructed. In this case, the parser throws an exception, unwinds the stack, and abandons the partially built AST.

See [here](#parse-errors) for error examples.

### AST Traversal

To traverse an AST, a class must adhere to the [Visitor](src/main/java/minijavac/ast/Visitor.java) interface by providing
an implementation method for each concrete node defined in the [ast](src/main/java/minijavac/ast) package.

Each Visitor implementation is free to define its own traversal state, argument types, and return types based on the specific requirements of its use case.

Typically, the argument type for a Visitor is an enum flag, which AST nodes use to indicate specific conditions to their 
direct children or nearby descendants within the node hierarchy.

Traversal state, on the other hand, operates at a broader level, allowing nodes to track their position within the overall AST
and facilitating the exchange of information between them.

### Enter

[Enter](src/main/java/minijavac/context/enter/Enter.java) is a Visitor implementation tasked with "entering" a given ClassDecl node
into the Compiler's global [SymbolTable](src/main/java/minijavac/context/SymbolTable.java). This process involves registering the class 
and all its members — fields, methods, and constructors — with the SymbolTable, ensuring that the information needed for semantic
analysis is available, both for the class itself and for any other classes that reference it.

Additionally, Enter is responsible for tracking all references to unresolved classes (i.e. those not registered with the SymbolTable) 
within the given class, so that the Compiler can potentially enqueue their respective files for parsing as well.

See [here](#enter-errors) for error examples.

### Context

[Context](src/main/java/minijavac/context/Context.java) is a Visitor implementation responsible for performing semantic
analysis on a given ClassDecl node. At this stage, a class has already been verified as *syntactically* valid, 
but now it must be verified to be *semantically* valid as well, according to the rules contained within [The Java Language Specification - Java SE 17 Edition](https://docs.oracle.com/javase/specs/jls/se17/html/index.html).

The analysis carried out by Context involves two key components, which are performed simultaneously during a single traversal of the AST: Attribution and Type Checking.

#### Attribution

Attribution ensures that every identifier (symbol) in the class correctly resolves to a corresponding [Declaration](src/main/java/minijavac/ast/Declaration.java). 
These declarations may represent:
- Local variables or parameters.
- Fields, methods, or constructors from the same class.
- Fields, methods, or constructors from other classes.
- The class itself.
- Another class.

To successfully resolve/attribute a declaration for a given identifier, three key questions must be answered:
 - Does the declaration exist within the current scope?
 - If it does exist, then is access to the declaration allowed?
 - If it is allowed, then is the declaration being referenced correctly?

If all three conditions are satisfied, the identifier is resolved as a valid [Reference](src/main/java/minijavac/ast/Reference.java), 
and the corresponding declaration is stored for later use during code generation.

See [here](#context---attribution-errors) and [here](#context---method-resolution-errors) for error examples.

#### Type Checking

The type checking performed by Context is relatively simple, as inheritance and generics are not supported (yet).

However, an important aspect of type checking that it does perform is the selective reporting of errors within expression trees.
To prevent a single type error from propagating and causing multiple cascading errors, any AST node that detects a type
mismatch returns a special error type. This error type is then considered compatible with all other types,
ensuring that only the original error gets logged to the user.

See [here](#context---type-checking-errors) for error examples.

### Gen

[Generator](src/main/java/minijavac/gen/Generator.java) handles the final step of the compilation process: converting
the fully verified ClassDecl node into a [ClassFile](src/main/java/minijavac/gen/file/ClassFile.java) instance. This instance can then
be serialized to disk as a Java `.class` file, ready for execution by the JVM.

#### ClassFile

A ClassFile, as defined in [Java Virtual Machine Specification - Chapter 4](https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-4.html), 
consists of several major sections:
- Constant Pool
- Fields
- Methods
- Attributes

##### Constant Pool

The [ConstantPool](src/main/java/minijavac/gen/constant/ConstantPool.java) is one of the most critical sections of the class file, as it stores the symbolic references and literal constants
needed during the execution of the program.

Example of a constant pool section generated by `minijavac` (obtained using `javap -v`):

```
Constant pool:
   #1 = Class              #2             // Test
   #2 = Utf8               Test
   #3 = Class              #4             // java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Methodref          #3.#9          // java/lang/Object."<init>":()V
   #9 = NameAndType        #5:#6          // "<init>":()V
  #10 = Utf8               main
  #11 = Integer            1000000
  #12 = Float              2000000.1f
  #13 = Methodref          #14.#16        // Other.build:(IFLTest;)LOther;
  #14 = Class              #15            // Other
  #15 = Utf8               Other
  #16 = NameAndType        #17:#18        // build:(IFLTest;)LOther;
  #17 = Utf8               build
  #18 = Utf8               (IFLTest;)LOther;
  #19 = Methodref          #14.#20        // Other.sub:(I)I
  #20 = NameAndType        #21:#22        // sub:(I)I
  #21 = Utf8               sub
  #22 = Utf8               (I)I
  #23 = Utf8               SourceFile
  #24 = Utf8               Test.java
```

##### Fields

The fields section of a class file describes all the member variables (fields) declared in the class.
Each [FieldEntry](src/main/java/minijavac/gen/file/FieldEntry.java) contains metadata such 
as the field's name, type, access modifiers, and any associated attributes.

Example of a fields section generated by `minijavac` (obtained using `javap -v -p`):

```
  private static int privstat;
    descriptor: I
    flags: (0x000a) ACC_PRIVATE, ACC_STATIC

  public static float pubstat;
    descriptor: F
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC

  private Test priv;
    descriptor: LTest;
    flags: (0x0002) ACC_PRIVATE

  public boolean pub;
    descriptor: Z
    flags: (0x0001) ACC_PUBLIC

  int[][] packpriv;
    descriptor: [[I
    flags: (0x0000)
```

##### Methods

The methods section defines the methods available in the class, including constructors, instance methods, and static methods.

Each [MethodEntry](src/main/java/minijavac/gen/file/MethodEntry.java) contains these sections:
- Method name
- Descriptor (parameter types and return type)
- Access flags
- [CodeAttribute](src/main/java/minijavac/gen/attribute/CodeAttribute.java)

Generator traverses the method bodies within the given class and translates their contents into JVM bytecode instructions, 
which are subsequently stored in the CodeAttribute of the corresponding MethodEntry.

Example of a methods section generated by `minijavac`:

```
Test();
    descriptor: ()V
    flags: (0x0000)
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #8                  // Method java/lang/Object."<init>":()V
         4: return

  private int add(int, int);
    descriptor: (II)I
    flags: (0x0002) ACC_PRIVATE
    Code:
      stack=2, locals=3, args_size=3
         0: iload_1
         1: iload_2
         2: iadd
         3: ireturn

  static float sub(float, float);
    descriptor: (FF)F
    flags: (0x0008) ACC_STATIC
    Code:
      stack=2, locals=2, args_size=2
         0: fload_0
         1: fload_1
         2: fsub
         3: freturn

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #22                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: iconst_1
         4: invokevirtual #16                 // Method java/io/PrintStream.println:(I)V
         7: return
```

##### Attributes

Attributes sections provide optional metadata at various levels of the class file hierarchy, offering additional 
information about their enclosing sections. At the class level, however, only one attribute is currently supported: the 
`SourceFileAttribute`, which specifies the name of the source file that defines the class.

#### CodeAttribute

[CodeAttribute](src/main/java/minijavac/) is the primary class utilized by Generator during its traversal of the AST,
serving as the central component for converting methods into executable JVM bytecode.

Minimally, it stores the JVM instructions generated from a method's body and manages the tracking and allocation of local
variables. It also provides the ability to buffer instructions that cannot immediately be added to the method, ensuring that
they are eventually inserted at the correct location within the bytecode.[^7]

[^7]: This delayed insertion is critical because the AST traversal does not always produce instructions in the exact order
required by the JVM, especially within constructs like method invocations and assignment statements.

Additionally, CodeAttribute facilitates the inclusion of control flow constructs such as conditionals (comparisons, if / else 
statements, ternary expressions) and loops (for, while, do-while) by:
- Maintaining a running byte offset and assigning it to instructions as they are added to the method’s bytecode, enabling Generator to later set the destinations of branching instructions.
- Tracking looping flow instructions (break, continue) to ensure they are handled correctly within nested loops and conditional blocks.
- Acting as the intermediary between the Generator and the [StackMapTableAttribute](src/main/java/minijavac/gen/attribute/stackmap/StackMapTableAttribute.java) - more on that below.

#### Instructions

A JVM [Instruction](src/main/java/minijavac/gen/instruction/Instruction.java) consists of a one-byte [OpCode](src/main/java/minijavac/gen/instruction/OpCode.java) 
denoting the operation, followed by zero or more operand bytes that provide the necessary arguments for executing the instruction.

It is the responsibility of the Generator to traverse the AST and convert each node into one or more corresponding instructions. 
These instructions, when assembled in the correct sequence, define the behavior of the compiled method and ultimately the program itself.

`minijavac` currently supports just over half of the complete JVM instruction set, covering a wide range of operations 
including arithmetic, control flow, method invocation, and memory management. 

Although this subset is sufficient for compiling the supported Java features, the current absence of optimizations means that 
`minijavac` typically cannot match the efficiency, terseness, or compactness of bytecode generated by `javac`.

However, efforts to reduce bytecode size are made where possible:
- Specialized load / store instructions for ints, floats, and objects:
  - Example:
    - Instead of generating `iload 1` (which requires an operand byte), the more compact `iload_1` is used (encoded in a single byte).
- Optimized constants for ints and floats:
  - Example:
    - 0 is loaded using the one-byte `iconst_0` instead of the more verbose `bipush 0`.

#### StackMapTableAttribute

Since Java 7, the [StackMapTableAttribute](src/main/java/minijavac/gen/attribute/stackmap/StackMapTableAttribute.java) 
has been a mandatory attribute for any CodeAttribute containing control flow instructions.

To ensure bytecode correctness, the JVM requires the inclusion of metadata describing the types of items on the operand stack 
and in the local variable table - at every bytecode location that serves as the *target of a branching instruction* (a jump).

This metadata is stored in frames ([StackMapFrame](src/main/java/minijavac/gen/attribute/stackmap/StackMapFrame.java)) within
the StackMapTableAttribute, with each frame corresponding to a specific byte offset within the CodeAttribute.

The frames are written to the class file in ascending order by byte offset. To optimize space, frames can often omit certain type information by referencing the state recorded in the previous frame.

For a better explanation, read [here](https://stackoverflow.com/a/25110513).

##### Implementation

To correctly populate the frames, the StackMapTableAttribute maintains a simulated operand stack[^8] and a scoped local variable table, 
both of which are continuously updated as the Generator adds instructions to the enclosing CodeAttribute.

When the Generator identifies a byte offset as a jump target, it signals the CodeAttribute to prepare to request a 
frame from the StackMapTableAttribute at that location. This ensures that a frame capturing the current state of the 
operands and local variables is then added for the appropriate offset.

[^8]: Thereby requiring each supported OpCode to be mapped to a corresponding StackTransformation - for each instruction, the
StackMapTableAttribute has to know exactly how to manipulate its operand stack to reflect the instruction's execution.

Note that the only reason that this approach works[^9] is the absence of more advanced features like type conversions and 
polymorphism - at that point, data flow analysis capabilities are likely needed.

[^9]: Probably not completely correctly, especially when dealing with uninitialized variables.

### Serialization

Once a Generator has fully populated a ClassFile instance, the Compiler can then proceed with writing the
ClassFile to disk in the binary format expected by the JVM.

This serialization is accomplished through the [Writable](src/main/java/minijavac/gen/file/Writable.java) interface, which
is implemented by ClassFile and all its components parts.

The Writable interface defines a single method:
```java
void writeTo(DataOutputStream stream) throws IOException;
```
 
This method is responsible for writing the bytecode representation of the implementing component's internal state to the provided `DataOutputStream`.

The serialization process is recursive, operating as a depth-first traversal of the graph formed by the ClassFile and its components:
- The ClassFile writes its components to the stream by calling their respective `writeTo` methods with the given stream.
- Each called component, in turn, then delegates the writing of its subcomponents by invoking their `writeTo` methods.
- This continues until the traversal reaches base cases, where individual values are written directly to the stream.

At the most granular level, the ClassFile is composed of 1, 2, and 4-byte units, which are implemented in `minijavac` by the
[U1](src/main/java/minijavac/gen/_byte/U1.java), [U2](src/main/java/minijavac/gen/_byte/U2.java), and [U4](src/main/java/minijavac/gen/_byte/U4.java) classes, respectively.
These classes ensure that values are written to disk using the correct byte lengths, as defined by the JVM specification.

Alternatively, when an Instruction is written to the stream:
- The implementing `writeTo` method writes the opcode byte and any operand bytes directly to the stream.

### Testing

To minimize the risk of regressions, `minijavac` is equipped with a robust test suite containing both unit and integration tests.

#### Unit Tests

For each compilation phase, there is a corresponding unit test suite located in `src/test/java/minijavac/unit`. Each test
case uses one or more input files from `src/test/resources/unit`, which are passed programmatically to the Compiler (bypassing the CLI). 

Once the specified phase has been completed, assertions are then made to verify the expected behavior.

Note that while these tests are referred to as "unit" tests, that term is somewhat imprecise here, as the tests for a given phase do
depend on the successful execution of all preceding phases.

Phases with test suites of note:

##### Parse

To verify the structure of the AST constructed by the Parser, [ParserTest](src/test/java/minijavac/unit/syntax/ParserTest.java) leverages
the generic functional interface [Asserter](src/test/java/minijavac/unit/Asserter.java) (a more appropriately named version of Consumer) for its assertions. 
This approach allows for a declarative syntax that remains readable even as the structure grows in complexity.

Test case example:

```java
class Test {
    int f ( ) { 
        int x = 1 + 2 - 3 * 4 / 5 ; 
    } 
}
```

Corresponding statement assertions:

```java
List<Asserter<Statement>> stmts = List.of(
                varDeclStmt(
                        intType(), 
                        "x",
                        binop(
                                binop(
                                        intLit(1),
                                        TokenKind.PLUS,
                                        intLit(2)
                                ),
                                TokenKind.MINUS,
                                binop(
                                        binop(
                                                intLit(3),
                                                TokenKind.MULTIPLY,
                                                intLit(4)
                                        ),
                                        TokenKind.DIVIDE,
                                        intLit(5)
                                )
                        )
                )
        );
```

##### Gen

To ensure that the Generator is producing the correct bytecode for a given class, the [Apache Commons BCEL (Byte Code Engineering Library)](https://commons.apache.org/proper/commons-bcel/) 
is used by [GeneratorTest](src/test/java/minijavac/unit/gen/GeneratorTest.java) to inspect and validate the generated bytecode.

Pre-assertion steps:
- Generating the class file byte stream:
  - A `ByteArrayOutputStream` is wrapped in a `DataOutputStream` and passed to the ClassFile's `writeTo` method, which serializes the class file contents into the byte stream.
- Parsing the bytecode with BCEL:
  - The populated `ByteArrayOutputStream` is converted to a `ByteArrayInputStream`, which is passed to a BCEL `ClassParser`, producing a `JavaClass` object representing the compiled class.

The test method can then assert against the `JavaClass` instance, verifying that its class structure, constant pool, fields, 
and methods all contain the expected information.

Test case example:

```java
class Test {
  void main(boolean b, boolean c, boolean d) {
    if (b) get(1);
    else if (c) get(2);
    else if (d) get(3);
    else get(4);
  }

  static void get(int i) {}
}
```

Expected instructions:

```java
List<String> instructions = List.of(
        "iload_1",
        "ifeq -> 11", // 1
        "iconst_1", // 4
        "invokestatic Test/get(I)V", // 5
        "goto -> 37", // 8
        "iload_2", // 11
        "ifeq -> 22", // 12
        "iconst_2", // 15
        "invokestatic Test/get(I)V", // 16
        "goto -> 37", // 19
        "iload_3", // 22
        "ifeq -> 33", // 23
        "iconst_3", // 26
        "invokestatic Test/get(I)V", // 27
        "goto -> 37", // 30
        "iconst_4", // 33
        "invokestatic Test/get(I)V", // 34
        "return" // 37
);
```

#### Integration Tests

The integration test suite in `minijavac` ([CompilerIT](src/test/java/minijavac/integration/CompilerIT.java)) tests the 
end-to-end correctness of the entire compilation process, by verifying that it successfully compiles supported Java programs
into valid `.class` files that execute as expected on the JVM.

Each test follows these steps:
- Setup:
  - The test specifies:
    - A source Java program stored in `src/test/resources/integration`.
    - The expected `.class` files.
    - The expected program output.
- Compilation:
  - The test runs the `minijavac` compiler via a command-line process, compiling the specified Java program into `.class` files that are written to a temporary directory.
  - After compilation, the test asserts that all expected `.class` files have been created.
- Execution:
  - The main class is executed using the standard `java` command with the compiled `.class` files on the classpath, with its output captured by a `BufferedReader`.
- Verification:
  - The captured output is compared to the expected output, ensuring that the compiled program behaves as expected.

## Appendix

### I. Usage

```java
class Test {
    Other o;
}
```

For the above file `Test.java`, referencing `src/Other.java`, possible usages include:

`minijavac Test.java src/Other.java`
- Parses:
  - `./Test.java`
  - `./src/Other.java`.
- Compiles to:
  - `./Test.class`
  - `./src/Other.class`.
- (Run with `java -cp .:src Test`).

`minijavac -sourcepath src Test.java`
- Parses `./Test.java`.
- Finds `Other` reference.
- Looks for `Other.java` in `./src/`.
- Parses `./src/Other.java`.
- Compiles to:
  - `./Test.class`
  - `./src/Other.class`.
- (Run with `java -cp .:src Test`).

`minijavac -sourcepath src -d tgt Test.java`
- Parses `./Test.java`
- Finds `Other` reference.
- Looks for `Other.java` in `./src/`.
- Parses `./src/Other.java`.
- Compiles to:
  - `./tgt/Test.class`
  - `./tgt/Other.class`.
- (Run with `java -cp tgt Test`).

### II. Errors



#### Parse Errors

##### Illegal Character

```java
class Test{} #
```

```
Test.java:1: error: illegal character: '#'
class Class{} #
              ^
1 error
```

##### Unclosed Comment

```java
class Test {/* comment
}
```

```
Test.java:1: error: unclosed comment
class Test {/* comment
            ^
Test.java:1: error: reached end of file while parsing
class Test {/* comment
            ^
2 errors
```

##### Illegal Start of Expression

```java
class Test {
    void p(){
        while ( 1 > = 0) {}
    }
}
```

```
Test.java:3: error: illegal start of expression
        while ( 1 > = 0) {}
                    ^
1 error
```

##### Illegal Start of Type

```java
class Test {
    public [] String x;
}
```

```
Test.java:2: error: illegal start of type
    public [] String x;
           ^
1 error
```

##### Not a Statement

```java
class IllegalStmt {
    void main () {
        this;
    }
}
```

```
Test.java:3: error: not a statement
        this;
            ^
1 error
```

##### Modifier __ Not Allowed Here

```java
class Test {
  static Test() {}
}
```

```
Test.java:2: error: modifier static not allowed here
    static Test() {}
               ^
1 error
```

##### __ Expected

```java
class Test {
    void main () {
        T b(3);
    }
}

class boolean {}
```

```
Test.java:3: error: '=' expected
        T b(3);
           ^
Test.java:7: error: '<identifier>' expected
class boolean {}
     ^
2 errors
```
#### Enter Errors

##### Duplicate Class

```java
class Test {}

class Test {}
```

```
Test.java:3: error: duplicate class: Test
class Test {}
^
1 error
```

##### Variable Already Defined

```java
class Test {
    int x;
    boolean x;
}
```

```
Test.java:3: error: variable x is already defined in class Test
    boolean x;
            ^
1 error
```

##### Method Already Defined

```java
class Test {
  int val;

  int add(int x, Test t) {
    return val + x + t.val;
  }

  int add(int x, Test t, boolean b) {
    return b ? val + x + t.val : x;
  }

  int add(int x, Test t) {
    return val + x + t.val;
  }
}
```

```
Test.java:12: error: method add(int,Test) is already defined in class Test
    int add(int x, Test t) {
        ^
1 error
```

##### Constructor Already Defined

```java
class Test {
  Test(int x, boolean b) {}

  Test(boolean b, int x) {}

  Test(int x, boolean b) {}
}
```

```
Test.java:6: error: constructor Test(int,boolean) is already defined in class Test
    Test(int x, boolean b) {}
    ^
1 error
```

#### Context - Attribution Errors

##### Cannot Find Symbol

```java
class Test {

  int y;

  Missing c;

  Test[] arr;

  public void foo(Fake f) {
    int x = y + z;
    y = get;
    while (y < 1) {
      y++;
      int a = 3;
    }
    y = a + 2;
    arr.y = 4;
  }

  int get() {
    return 1;
  }
}
```

```
Test.java:5: error: cannot find symbol
    Missing c;
    ^
symbol:   class Missing
location: class Test
Test.java:7: error: cannot find symbol
    public void foo(Fake f) {
                    ^
symbol:   class Fake
location: class Test
Test.java:8: error: cannot find symbol
        int x = y + z;
                    ^
symbol:   variable z
location: class Test
Test.java:9: error: cannot find symbol
        y = get;
            ^
symbol:   variable get
location: class Test
Test.java:14: error: cannot find symbol
        y = a + 2;
            ^
symbol:   variable a
location: class Test
Test.java:17: error: cannot find symbol
        arr.y = 4;
            ^
symbol:   variable y
location: variable arr of type Test[]
6 errors
```

##### Cannot Find Symbol (Qualified Reference)

```
class Test {

    public void foo() {
        Other o = new Other();
        int x = o.get;

        Other[] oarr = new Other[5];
        oarr[0].x = 1;

        int z = o.t.val;
    }
}

class Other {

    Test t;

    int get() {
        return 1;
    }
}
```

```
Test.java:5: error: cannot find symbol
        int x = o.get;
                  ^
symbol:   variable get
location: variable o of type Other
Test.java:8: error: cannot find symbol
        oarr[0].x = 1;
                ^
symbol:   variable x
location: class Other
Test.java:10: error: cannot find symbol
        int z = o.t.val;
                    ^
symbol:   variable val
location: variable t of type Test
3 errors
```

##### Variable Already Defined

```
class Test {

    public void foo(int x) {
        int x = 1;
        int y = 2;
        int y = 3;
        if (x > 0) {
            int z = 2;
        }
        int z = 3;
    }
}
```

```
Test.java:4: error: variable x is already defined in method foo(int)
        int x = 1;
            ^
Test.java:6: error: variable y is already defined in method foo(int)
        int y = 3;
            ^
2 errors
```

##### Variable Declaration Not Allowed Here

```java
class Test {

    public void foo(int x) {
        if (x > 0) int y = 2;
    }
}
```

```
Test.java:4: error: variable declaration not allowed here
        if (x > 0) int y = 2;
                       ^
1 error
```

##### Variable Might Not Have Been Initialized

```
class Test {

    public void foo() {
        int x = 1 + x;
    }
}
```

```
Test.java:4: error: variable x might not have been initialized
        int x = 1 + x;
                    ^
1 error
```

##### __ Cannot Be Dereferenced

```java
class Test {

    public void foo(int y) {
        int x = y.foo;
        boolean[] a = new boolean[5];
        a[0].x = 1;
        float r = get().x;
        r = getVoid().x;
    }

    float get() {
        return 1.1;
    }

    void getVoid() {
        return;
    }
}
```

```
Test.java:4: error: int cannot be dereferenced
        int x = y.foo;
                  ^
Test.java:6: error: boolean cannot be dereferenced
        a[0].x = 1;
             ^
Test.java:7: error: float cannot be dereferenced
        float r = get().x;
                        ^
Test.java:8: error: void cannot be dereferenced
        r = getVoid().x;
                      ^
4 errors
```

##### Array Required, But __ Found

```java
class Test {

    public void foo() {
        int a = 1;
        a[0] = 2;
        Test f = new Test();
        f[0] = 2;
        int[] arr = new int[2];
        int x = arr[1][2];
    }
}
```

```
Test.java:5: error: array required, but int found
        a[0] = 2;
        ^
Test.java:7: error: array required, but Test found
        f[0] = 2;
        ^
Test.java:9: error: array required, but int found
        int x = arr[1][2];
                       ^
3 errors
```

##### Private Access

```java
class Test {

    public void foo(Other o) {
        o.x = 1;
        int x = o.xm(1, true, new int[2][2]);
    }
}

class Other {
    private int x;
    private int xm(int i, boolean b, int[][] ix) {
        return 1;
    }
}
```

```
Test.java:4: error: x has private access in Other
        o.x = 1;
          ^
Test.java:5: error: xm(int,boolean,int[][]) has private access in Other
        int x = o.xm(1, true, new int[2][2]);
                  ^
2 errors
```

##### Non-Static Method / Variable Cannot Be Referenced From a Static Context

```java
class Test {
    int x;

    static void main() {
        int val = x;
        val = getX(1);
        val = this.x;
    }

    int getX(int p) {
        return x + p;
    }
}
```

```
Test.java:5: error: non-static variable x cannot be referenced from a static context
        int val = x;
                  ^
Test.java:6: error: non-static method getX(int) cannot be referenced from a static context
        val = getX(1);
              ^
Test.java:7: error: non-static variable this cannot be referenced from a static context
        val = this.x;
              ^
3 errors
```

##### __ Outside of Loop

```java
class Test {

    public void foo() {
        break;
        continue;
    }
}
```

```
Test.java:4: error: break outside of loop
        break;
        ^
Test.java:5: error: continue outside of loop
        continue;
        ^
2 errors
```

##### Call to This Must be First Statement in Constructor

```
class Test {
    int x;

    Test(int x) {
        this.x = x;
    }

    Test() {
        int x = 1;
        this(x);
    }
}
```

```
Test.java:10: error: call to this must be first statement in constructor
        this(x);
        ^
1 error
```

##### Cannot Assign a Value to Final Variable

```java
class Test {

  final int x;

  void main() {
    x = 2;
    final int b = 2;
    b = 3;
  }
}
```

```
Test.java:6: error: cannot assign a value to final variable x
        x = 2;
        ^
Test.java:8: error: cannot assign a value to final variable b
        b = 3;
        ^
2 errors
```

#### Context - Method Resolution Errors

##### Cannot Find Symbol

```java
class Test {
    Other o;
    void main() {
        get();
        get(1);
        o.get(true, 1);
    }

    void set() {}
}

class Other {
    void set() {}
}
```

```
Test.java:4: error: cannot find symbol
        get();
        ^
symbol:   method get()
location: class Test
Test.java:5: error: cannot find symbol
        get(1);
        ^
symbol:   method get(int)
location: class Test
Test.java:6: error: cannot find symbol
        o.get(true, 1);
          ^
symbol:   method get(boolean,int)
location: variable o of type Other
3 errors
```

##### Method / Constructor Cannot Be Applied to Given Types

```java
class Test {
  void main() {
    int x = f(1);
    Other o = new Other();
  }

  int f() {
    return 1;
  }
}

class Other {
  Other(int x) {}
}
```

```
Test.java:3: error: method f in class Test cannot be applied to given types;
        int x = f(1);
                ^
  required: no arguments
  found:    int
  reason: actual and formal argument lists differ in length
Test.java:4: error: constructor Other in class Other cannot be applied to given types;
        Other o = new Other();
                      ^
  required: int
  found:    no arguments
  reason: actual and formal argument lists differ in length
2 errors
```

##### Incompatible Types (Single Candidate)

```java
class Test {
    void main() {
        int x = f(1);
        int y = g(1, true);
    }

    int f(boolean a) {
        return 1;
    }

    int g(int a, int b) {
        return 1;
    }
}
```

```
Test.java:3: error: incompatible types: int cannot be converted to boolean
        int x = f(1);
                  ^
Test.java:4: error: incompatible types: boolean cannot be converted to int
        int y = g(1, true);
                     ^
2 errors
```

##### No Suitable Method Found

```java
class Test {
    void main() {
        int x = f(1);
    }

    int f() {}

    int f(int i, int i2) {
        return 1;
    }
}
```

```
Test.java:3: error: no suitable method found for f(int)
        int x = f(1);
                ^
    method Test.f() is not applicable
      (actual and formal argument lists differ in length)
    method Test.f(int,int) is not applicable
      (actual and formal argument lists differ in length)
1 error
```

##### Incompatible Types (Multiple Candidates)

```java
class Test {
  void main() {
    int x = f(1);
  }

  int f(boolean i) {
    return 1;
  }

  int f(Test[] t) {
    return 1;
  }

  int f(int i, int i2) {
    return 1;
  }
}
```

```
Test.java:3: error: no suitable method found for f(int)
        int x = f(1);
                ^
    method Test.f(boolean) is not applicable
      (argument mismatch; int cannot be converted to boolean)
    method Test.f(Test[]) is not applicable
      (argument mismatch; int cannot be converted to Test[])
1 error
```

#### Context - Type Checking Errors

##### Bad Operand Type For Unary Operator

```java
class Test {
  void main(boolean b, float f, Test t) {
    int z = ++b;
    z = ~f;
    z = ++t;
    b = !f;
    ++b;
    b--;
  }
}
```

```
Test.java:3: error: bad operand type boolean for unary operator '++'
        int z = ++b;
                ^
Test.java:4: error: bad operand type float for unary operator '~'
        z = ~f;
            ^
Test.java:5: error: bad operand type Test for unary operator '++'
        z = ++t;
            ^
Test.java:6: error: bad operand type float for unary operator '!'
        b = !f;
            ^
Test.java:7: error: bad operand type boolean for unary operator '++'
        ++b;
        ^
Test.java:8: error: bad operand type boolean for unary operator '--'
        b--;
         ^
6 errors
```

##### Bad Operand Types For Binary Operator

```java
class Test {
  void main() {
    boolean b = 1 && false;
    int x = true + 1;
    int y = false <= 1;
    int z = true == 1;
    z += new Test();
  }
}
```

```
Test.java:3: error: bad operand types for binary operator '&&'
        boolean b = 1 && false;
                      ^
  first type:  int
  second type: boolean
Test.java:4: error: bad operand types for binary operator '+'
        int x = true + 1;
                     ^
  first type:  boolean
  second type: int
Test.java:5: error: bad operand types for binary operator '<='
        int y = false <= 1;
                      ^
  first type:  boolean
  second type: int
Test.java:6: error: bad operand types for binary operator '=='
        int z = true == 1;
                     ^
  first type:  boolean
  second type: int
Test.java:7: error: bad operand types for binary operator '+'
        z += new Test();
          ^
  first type:  int
  second type: Test
5 errors
```

##### Incompatible Types - Cannot Be Converted

```java
class Test {
  void main() {
    int x = false;
    int[] x = new int[true];

    Test t = new Test();
    Test[] tarr = new Test[2];
    t = tarr;

    if (1) {}
    while (t) {}
    for (int i=0; i+3; i++) {}

    boolean b = get();

    b = Other.f;
  }

  int get() {
    return 1;
  }
}

class Other {
  static float f;
}
```

```
Test.java:3: error: incompatible types: boolean cannot be converted to int
        int x = false;
                ^
Test.java:4: error: variable x is already defined in method main()
        int[] x = new int[true];
              ^
Test.java:4: error: incompatible types: boolean cannot be converted to int
        int[] x = new int[true];
                          ^
Test.java:8: error: incompatible types: Test[] cannot be converted to Test
        t = tarr;
            ^
Test.java:10: error: incompatible types: int cannot be converted to boolean
        if (1) {}
            ^
Test.java:11: error: incompatible types: Test cannot be converted to boolean
        while (t) {}
               ^
Test.java:12: error: incompatible types: int cannot be converted to boolean
        for (int i=0; i+3; i++) {}
                       ^
Test.java:14: error: incompatible types: int cannot be converted to boolean
        boolean b = get();
                    ^
Test.java:16: error: incompatible types: float cannot be converted to boolean
        b = Other.f;
            ^
9 errors
```

##### Incompatible Types - Possible Lossy Conversion

```java
class Test {
  void main() {
    int i = 2.5;
  }
}
```

```
Test.java:3: error: incompatible types: possible lossy conversion from float to int
        int i = 2.5;
                ^
1 error
```

##### Incompatible Types - Missing Return Value

```java
class Test {
    int main() {
        return;
    }
}
```

```
Test.java:3: error: incompatible types: missing return value
        return;
        ^
1 error
```

##### Incompatible Types - Unexpected Return Value

```java
class Test {
    void main() {
        return 1;
    }
}
```

```
Test.java:3: error: incompatible types: unexpected return value
        return 1;
               ^
1 error
```

##### Unexpected Type

```java
class Test {
    void main() {
        ++i();
    }

    int i() { return 1; }
}
```

```
Test.java:3: error: unexpected type
        ++i();
          ^
  required: variable
  found:    value
1 error
```

### III. Grammar

The complete, formal grammar for the supported subset of the Java language:

#### Top-Level

Program  ::=  ( ClassDeclaration )+

ClassDeclaration  ::=  **class** *identifier* **{** ( FieldDeclaration | MethodDeclaration | ConstructorDeclaration )* **}**

FieldDeclaration  ::=  Visibility Access Modify Type *identifier* **;**

MethodDeclaration ::= Visibility Access Modify ( Type | **void** ) *identifier* **(** ParameterList? **)** **{** Statement* **}**

ConstructorDeclaration  ::=  Visibility *identifier* **(** ParameterList? **)** **{** Statement* **}**

Visibility  ::=  ( **public** | **private** )?

Access  ::=  **static**?

Modify  ::=  **final**?

ParameterList  ::=  Modify Type *identifier* ( **,** Modify Type *identifier* )*

#### Statements

Statement  ::=
BlockStatement
|  ReturnStatement
|  IfStatement
|  WhileStatement
|  DoWhileStatement
|  ForStatement
|  BreakStatement
|  ContinueStatement
|  VarDeclStatement
|  AssignStatement
|  CallStatement
|  ExpressionStatement

BlockStatement  ::=  **{** Statement* **}**

ReturnStatement  ::=  **return** Expression? **;**

IfStatement  ::=  **if** **(** Expression **)** Statement ( **else** **if** **(** Expression **)** Statement )* ( **else** Statement )?

WhileStatement  ::=  **while** **(** Expression **)** Statement

DoWhileStatement  ::=  **do** Statement **while** **(** Expression **)** **;**

ForStatement  ::=  **for** **(** VarDeclStatement Expression **;** UnaryExpression **)** Statement

BreakStatement  ::=  **break** **;**

ContinueStatement  ::=  **continue** **;**

VarDeclStatement  ::=  Modify Type *identifier* ( **=** Expression )? **;**

AssignStatement  ::=  Reference ( **=** | **+=** | **-=** | **\*=** | **\\=** | **%=** | **&=** | **^=** | **|=** | **>>=** | **<<=** | **>>>=** ) Expression **;**

CallStatement  ::=  Reference **;**

ExpressionStatement  ::=  UnaryExpression **;**

#### References

Reference  ::=  IdentifierReference | ThisReference | IndexedReference | CallReference | QualifiedReference

IdentifierReference  ::=  *identifier*

ThisReference  ::=  **this**

IndexedReference  ::=  ( IdentifierReference | CallReference | QualifiedReference ) ( **\[** Expression **\]** )+

CallReference  ::=  ( IdentifierReference | ThisReference | QualifiedReference ) ExpressionList

QualifiedReference  ::=  Reference **.** *identifier*

#### Expressions

ExpressionList  ::=  **(** Expression ( **,** Expression)* **)**

IndexExpression  ::=  **\[** Expression **\]**

Expression  ::=  TernaryExpression

TernaryExpression  ::=  OrExpression ( **?** TernaryExpression **:** TernaryExpression )?

OrExpression  ::=  AndExpression ( **||** AndExpression )*

AndExpression  ::=  BitwiseInclusiveOrExpression ( **&&** BitwiseInclusiveOrExpression )*

BitwiseInclusiveOrExpression  ::=  BitwiseExclusiveOrExpression ( **|** BitwiseExclusiveOrExpression )*

BitwiseExclusiveOrExpression  ::=  BitwiseAndExpression (  **^** BitwiseAndExpression )*

BitwiseAndExpression  ::=  EqualityExpression ( **&** EqualityExpression )*

EqualityExpression  ::=  RelationalExpression ( ( **\==** | **!=** ) RelationalExpression )*

RelationalExpression  ::=  ShiftExpression  ( ( **<** | **>** | **<=** | **>=** ) ShiftExpression )*

ShiftExpression  ::=  AdditiveExpression ( ( **<<** | **>>** | **>>>** ) AdditiveExpression )*

AdditiveExpression  ::= MultiplicativeExpression ( ( **+** | **-**) MultiplicativeExpression )*

MultiplicativeExpression  ::= UnaryExpression ( ( **\***, **/**, **%** ) UnaryExpression )*

UnaryExpression  ::=  ( **-** | **!** | **~** | **++** | **--** ) UnaryExpression | PostfixExpression

PostfixExpression  ::=  BaseExpression ( **++** | **--** )?

BaseExpression  ::=  
**(** Expression **)**
|  *integer*
|  *float*
|  **true**
|  **false**
|  **null**
|  **new** BaseType ( IndexExpression+ | ( **\[** **]** )+ ArrayInitExpression | ExpressionList )
|  Reference

ArrayInitExpression  ::=  **{** ( ( ArrayInitExpression | Expression ) **,** )* **}**

#### Types, Identifiers, Literals

BaseType  ::=
**int**
|  **float**
|  **boolean**
|  *identifier*

Type  ::=  BaseType ( **\[** **]** )*

*identifier*  ::=  \^[a-zA-Z_\$][a-zA-Z0-9_\$]*$

*integer*  ::=  \^[0-9]+$

*float*  ::=  \^[0-9]+\.[0-9]*$